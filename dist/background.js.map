{"version":3,"file":"background.js","mappings":"MACAA,QAAQC,IAAI,gCAGZ,MAAMC,EAAyB,CAC7BC,SAAU,qBACVC,QAAS,qBACTC,QAAS,sBACTC,gBAAiB,sBAInB,IAAIC,EAKE,IAAIC,IA4LV,SAASC,EAAeC,GAEtB,IAAK,MAAOC,EAAMC,KAAYC,OAAOC,QAAQZ,GAAyB,CACpE,MAAMa,EAAUL,EAAKM,MAAMJ,GAC3B,GAAIG,GAAWA,EAAQE,OAAS,EAC9B,MAAO,CACLC,GAAIH,EAAQ,GACZJ,KAAMA,EAGZ,CAEA,OAAO,IACT,CAGA,SAASQ,IAMP,MAAMC,EAKD,GAGCC,EAAW,CACflB,SAAU,qBACVE,QAAS,uBAILiB,EAASC,SAASC,iBACtBD,SAASE,KACTC,WAAWC,UACX,MAGIC,EAAoB,GAC1B,IAAIC,EACJ,KAAOA,EAAOP,EAAOQ,YACnBF,EAAUG,KAAKF,GAuCjB,OAnCAD,EAAUI,QAAQC,IAChB,MAAMvB,EAAOuB,EAASC,aAAe,GAErC,IAAK,MAAOvB,EAAMC,KAAYC,OAAOC,QAAQO,GAAW,CACtD,MAAMN,EAAUL,EAAKM,MAAMJ,GACvBG,GACFA,EAAQiB,QAAQhB,IAEd,MAAMmB,EAAQzB,EAAK0B,QAAQpB,GACrBqB,EAAQC,KAAKC,IAAI,EAAGJ,EAAQ,IAC5BK,EAAMF,KAAKG,IAAI/B,EAAKO,OAAQkB,EAAQnB,EAAMC,OAAS,IACnDyB,EAAUhC,EAAKiC,MAAMN,EAAOG,GAG5BI,EAAUX,EAASY,cACnBC,EAAcF,EAClB,GAAGA,EAAQG,QAAQC,gBAAgBJ,EAAQK,UAAY,IAAML,EAAQK,UAAY,KACjF,OAEF7B,EAAYW,KAAK,CACfb,GAAIF,EACJL,KAAMA,EACN+B,QAASA,EAAQQ,OACjBN,QAASE,KAIjB,IAIgB1B,EAAY+B,OAAO,CAACjC,EAAIiB,EAAOiB,IAC/CjB,IAAUiB,EAAKC,UAAUC,GAAKA,EAAEpC,KAAOA,EAAGA,IAI9C,CAeAqC,eAAeC,EAA2BC,EAAeC,GACvD,UACQC,OAAOC,cAAcC,OAAO,CAChClD,KAAM,QACNmD,QAAS,0BACTL,MAAOA,EACPC,QAASA,GAEb,CAAE,MAAOK,GACP/D,QAAQ+D,MAAM,uBAAwBA,EACxC,CACF,CAxSAJ,OAAOK,QAAQC,YAAYC,YAAY,KAErCP,OAAOQ,aAAaN,OAAO,CACzBO,GAAI,YACJX,MAAO,2BACPY,SAAU,CAAC,eAGbV,OAAOQ,aAAaN,OAAO,CACzBO,GAAI,gBACJX,MAAO,8BACPY,SAAU,CAAC,eAGbV,OAAOQ,aAAaN,OAAO,CACzBO,GAAI,gBACJX,MAAO,4BACPY,SAAU,CAAC,UAGbV,OAAOQ,aAAaN,OAAO,CACzBO,GAAI,gBACJX,MAAO,6BACPY,SAAU,CAAC,UAIbV,OAAOQ,aAAaN,OAAO,CACzBO,GAAI,gBACJX,MAAO,oBACPY,SAAU,CAAC,aACXC,SAAU,cAGZX,OAAOQ,aAAaN,OAAO,CACzBO,GAAI,oBACJX,MAAO,8BACPY,SAAU,CAAC,aACXC,SAAU,kBAGZX,OAAOQ,aAAaN,OAAO,CACzBO,GAAI,sBACJX,MAAO,2BACPY,SAAU,CAAC,aACXC,SAAU,kBAGZX,OAAOQ,aAAaN,OAAO,CACzBO,GAAI,mBACJX,MAAO,wBACPY,SAAU,CAAC,aACXC,SAAU,kBAGZtE,QAAQC,IAAI,2BAId0D,OAAOQ,aAAaI,UAAUL,YAAYX,MAAOiB,EAAMC,KACrDzE,QAAQC,IAAI,wBAAyBuE,EAAKE,WAAYF,GAEtD,IACE,OAAQA,EAAKE,YACX,IAAK,YACL,IAAK,oBACL,IAAK,sBACL,IAAK,yBAsBXnB,eAAgCiB,EAAuCC,GACrE,IAAKD,EAAKG,gBAAkBF,GAAKL,GAAI,OAErC,MAAMQ,EAAeJ,EAAKG,cAAczB,OAClC2B,EAAapE,EAAemE,GAoLpC,IAA6BE,EAlLvBD,SAEIlB,OAAOoB,QAAQC,MAAMC,IAAI,CAC7BC,WAAYL,EAAW3D,GACvBiE,QA8KuBL,EA9KKN,EAAKE,WA+KG,CACtC,kBAAqB,WACrB,oBAAuB,aACvB,iBAAoB,UACpB,UAAa,WAGAI,IAAW,WArLtBM,iBAAiB,EACjBC,UAAWZ,EAAIa,IACfC,YAAad,EAAIhB,MACjB+B,UAAWC,KAAKC,MAChBC,iBAAkBf,UAIdpB,EAA2B,cAAe,SAASqB,EAAWlE,SAASkE,EAAW3D,GAAGyB,MAAM,EAAG,gBAG9FgB,OAAOiC,OAAOC,mBAEdrC,EAA2B,cAAe,oDAEpD,CA/CcsC,CAAiBtB,EAAMC,GAC7B,MAEF,IAAK,sBA+CXlB,eAAmCiB,EAAuCC,GACxE,IAAKD,EAAKG,gBAAkBF,GAAKL,GAAI,OAErC,MACMS,EAAapE,EADE+D,EAAKG,cAAczB,QAGpC2B,UAEIlB,OAAOoB,QAAQC,MAAMC,IAAI,CAC7BC,WAAYL,EAAW3D,GACvB6E,WAAY,iBACZX,iBAAiB,EACjBC,UAAWZ,EAAIa,IACfE,UAAWC,KAAKC,cAGZlC,EAA2B,kBAAmB,gCAAgCqB,EAAW3D,GAAGyB,MAAM,EAAG,gBACrGgB,OAAOiC,OAAOC,YAExB,CAjEcG,CAAoBxB,EAAMC,GAChC,MAEF,IAAK,sBAiEXlB,eAAqCkB,GACnC,GAAKA,GAAKL,GAEV,IAEE,MAAM6B,QAAgBtC,OAAOuC,UAAUC,cAAc,CACnDC,OAAQ,CAAEC,MAAO5B,EAAIL,IACrBkC,KAAMnF,IAGR,GAAI8E,GAAWA,EAAQ,IAAIM,OAAQ,CACjC,MAAMnF,EAAc6E,EAAQ,GAAGM,OAE3BnF,EAAYH,OAAS,SAEjB0C,OAAOoB,QAAQC,MAAMC,IAAI,CAC7B7D,YAAaA,EACboF,mBAAmB,EACnBnB,UAAWZ,EAAIa,IACfC,YAAad,EAAIhB,MACjB+B,UAAWC,KAAKC,cAGZlC,EACJ,eACA,SAASpC,EAAYH,oBAAoBG,EAAYH,OAAS,EAAI,KAAO,yBAGrE0C,OAAOiC,OAAOC,mBAEdrC,EAA2B,eAAgB,wCAErD,CACF,CAAE,MAAOO,GACP/D,QAAQ+D,MAAM,4BAA6BA,SACrCP,EAA2B,mBAAoB,uCACvD,CACF,CArGciD,CAAsBhC,GAC5B,MAEF,IAAK,sBAqGXlB,uBACQI,OAAOiC,OAAOC,WACtB,CAtGca,GAGZ,CAAE,MAAO3C,GACP/D,QAAQ+D,MAAM,8BAA+BA,EAC/C,IAsNFJ,OAAOK,QAAQ2C,UAAUzC,YAAY,CAAC0C,EAASC,EAAQC,KAGrD,OAFA9G,QAAQC,IAAI,+BAAgC2G,GAEpCA,EAAQhB,QACd,IAAK,aAqBTrC,eACEqD,EACAC,EACAC,GAEA,UACQnD,OAAOoB,QAAQC,MAAMC,IAAI,CAC7BC,WAAY0B,EAAQG,KACpBC,aAAa,EACbxB,UAAWC,KAAKC,QAElBoB,EAAa,CAAEG,SAAS,GAC1B,CAAE,MAAOlD,GACP+C,EAAa,CAAEG,SAAS,EAAOlD,MAAQA,EAAgBL,SACzD,CACF,CAnCMwD,CAAuBN,EAASC,EAAQC,GACxC,MAEF,IAAK,eAmCTvD,eACEqD,EACAC,EACAC,GAEA,IAeEA,QAdqBnD,OAAOoB,QAAQC,MAAMmC,IAAI,CAC5C,aACA,SACA,kBACA,oBACA,cACA,YACA,cACA,mBACA,cACA,aACA,qBAMIxD,OAAOoB,QAAQC,MAAMoC,OAAO,CAChC,kBACA,oBACA,eAEJ,CAAE,MAAOrD,GACP+C,EAAa,CAAE/C,MAAQA,EAAgBL,SACzC,CACF,CAjEM2D,CAAyBT,EAASC,EAAQC,GAC1C,MAEF,IAAK,kBAiETvD,eACEqD,EACAC,EACAC,GAEA,IAEEA,QADqBnD,OAAOoB,QAAQC,MAAMmC,IAAI,CAAC,gBAEjD,CAAE,MAAOpD,GACP+C,EAAa,CAAE/C,MAAQA,EAAgBL,SACzC,CACF,CA3EM4D,CAA4BV,EAASC,EAAQC,GAC7C,MAEF,IAAK,mBA2ETvD,eACEqD,EACAC,EACAC,GAEA,UACQnD,OAAOoB,QAAQC,MAAMuC,QAC3BT,EAAa,CAAEG,SAAS,GAC1B,CAAE,MAAOlD,GACP+C,EAAa,CAAEG,SAAS,EAAOlD,MAAQA,EAAgBL,SACzD,CACF,CArFM8D,CAA6BZ,EAASC,EAAQC,GAIlD,OAAO,IAoFTnD,OAAOiC,OAAOrB,UAAUL,YAAaO,IACnCd,OAAOiC,OAAOC,cAIhBlC,OAAO8D,KAAKC,UAAUxD,YAAYX,MAAO8C,EAAOsB,EAAYlD,KAC1D,GAA0B,aAAtBkD,EAAWC,QAAyBnD,EAAIa,IAE1C,IACE,MAAMW,QAAgBtC,OAAOuC,UAAUC,cAAc,CACnDC,OAAQ,CAAEC,MAAOA,GACjBC,KAAMnF,IAGR,GAAI8E,GAAWA,EAAQ,IAAIM,OAAQ,CACjC,MAAMsB,EAAM5B,EAAQ,GAAGM,OACnBsB,EAAI5G,OAAS,IACfV,EAAsB0E,IAAIoB,EAAOwB,EAAIC,IAAI5G,IAAM,IAC1CA,EACHsE,UAAWC,KAAKC,gBAIZ/B,OAAOiC,OAAOmC,aAAa,CAC/BrH,KAAMmH,EAAI5G,OAAO+G,WACjB3B,MAAOA,UAGH1C,OAAOiC,OAAOqC,wBAAwB,CAC1CC,MAAO,UACP7B,MAAOA,IAGb,CACF,CAAE,MAAOtC,GAET,IAKJJ,OAAO8D,KAAKU,UAAUjE,YAAamC,IACjC9F,EAAsB6H,OAAO/B,I","sources":["webpack://ip-graph-extension/./src/background/background.ts"],"sourcesContent":["// src/background/background.ts\nconsole.log('IP Graph Extension installed');\n\n// IP address patterns for detection (renamed to avoid conflict)\nconst BACKGROUND_IP_PATTERNS = {\n  ethereum: /0x[a-fA-F0-9]{40}/g,\n  storyIP: /0x[a-fA-F0-9]{40}/g,\n  ensName: /[a-zA-Z0-9-]+\\.eth/g,\n  contractAddress: /0x[a-fA-F0-9]{40}/g\n};\n\n// Storage for detected IPs (renamed to avoid conflict)\nlet backgroundDetectedIPs: Map<number, Array<{\n  ip: string;\n  type: string;\n  context: string;\n  timestamp: number;\n}>> = new Map();\n\n// Create context menus on installation\nchrome.runtime.onInstalled.addListener(() => {\n  // Create main context menus directly without loop to avoid type issues\n  chrome.contextMenus.create({\n    id: 'analyzeIP',\n    title: '🔍 Analyze IP with Graph',\n    contexts: ['selection']\n  });\n\n  chrome.contextMenus.create({\n    id: 'searchStoryIP',\n    title: '📊 Search in Story Protocol',\n    contexts: ['selection']\n  });\n\n  chrome.contextMenus.create({\n    id: 'detectPageIPs',\n    title: '🎯 Detect All IPs on Page',\n    contexts: ['page']\n  });\n\n  chrome.contextMenus.create({\n    id: 'openExtension',\n    title: '🚀 Open IP Graph Extension',\n    contexts: ['page']\n  });\n\n  // Create submenu for detected IP types\n  chrome.contextMenus.create({\n    id: 'ipTypeSubmenu',\n    title: '🔗 IP Asset Types',\n    contexts: ['selection'],\n    parentId: 'analyzeIP'\n  });\n\n  chrome.contextMenus.create({\n    id: 'analyzeAsOriginal',\n    title: '🎨 Analyze as Original Work',\n    contexts: ['selection'],\n    parentId: 'ipTypeSubmenu'\n  });\n\n  chrome.contextMenus.create({\n    id: 'analyzeAsDerivative',\n    title: '🔄 Analyze as Derivative',\n    contexts: ['selection'],\n    parentId: 'ipTypeSubmenu'\n  });\n\n  chrome.contextMenus.create({\n    id: 'analyzeAsLicense',\n    title: '📜 Analyze as License',\n    contexts: ['selection'],\n    parentId: 'ipTypeSubmenu'\n  });\n\n  console.log('Context menus created');\n});\n\n// Handle context menu clicks\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n  console.log('Context menu clicked:', info.menuItemId, info);\n\n  try {\n    switch (info.menuItemId) {\n      case 'analyzeIP':\n      case 'analyzeAsOriginal':\n      case 'analyzeAsDerivative':\n      case 'analyzeAsLicense':\n        await handleIPAnalysis(info, tab);\n        break;\n        \n      case 'searchStoryIP':\n        await handleStoryIPSearch(info, tab);\n        break;\n        \n      case 'detectPageIPs':\n        await handlePageIPDetection(tab);\n        break;\n        \n      case 'openExtension':\n        await handleOpenExtension();\n        break;\n    }\n  } catch (error) {\n    console.error('Context menu handler error:', error);\n  }\n});\n\n// Handle IP analysis from context menu\nasync function handleIPAnalysis(info: chrome.contextMenus.OnClickData, tab?: chrome.tabs.Tab): Promise<void> {\n  if (!info.selectionText || !tab?.id) return;\n\n  const selectedText = info.selectionText.trim();\n  const detectedIP = detectIPInText(selectedText);\n\n  if (detectedIP) {\n    // Store the IP for analysis\n    await chrome.storage.local.set({\n      selectedIP: detectedIP.ip,\n      ipType: getIPTypeFromMenuId(info.menuItemId as string),\n      fromContextMenu: true,\n      sourceUrl: tab.url,\n      sourceTitle: tab.title,\n      timestamp: Date.now(),\n      selectionContext: selectedText\n    });\n\n    // Show notification\n    await showBackgroundNotification('IP Detected', `Found ${detectedIP.type}: ${detectedIP.ip.slice(0, 10)}...`);\n\n    // Open extension popup\n    await chrome.action.openPopup();\n  } else {\n    await showBackgroundNotification('No IP Found', 'Selected text does not contain a valid IP address');\n  }\n}\n\n// Handle Story IP search\nasync function handleStoryIPSearch(info: chrome.contextMenus.OnClickData, tab?: chrome.tabs.Tab): Promise<void> {\n  if (!info.selectionText || !tab?.id) return;\n\n  const selectedText = info.selectionText.trim();\n  const detectedIP = detectIPInText(selectedText);\n\n  if (detectedIP) {\n    // Store for Story Protocol specific search\n    await chrome.storage.local.set({\n      selectedIP: detectedIP.ip,\n      searchType: 'story-protocol',\n      fromContextMenu: true,\n      sourceUrl: tab.url,\n      timestamp: Date.now()\n    });\n\n    await showBackgroundNotification('Story IP Search', `Searching Story Protocol for ${detectedIP.ip.slice(0, 10)}...`);\n    await chrome.action.openPopup();\n  }\n}\n\n// Handle page-wide IP detection\nasync function handlePageIPDetection(tab?: chrome.tabs.Tab): Promise<void> {\n  if (!tab?.id) return;\n\n  try {\n    // Inject content script to detect IPs\n    const results = await chrome.scripting.executeScript({\n      target: { tabId: tab.id },\n      func: injectableDetectAllIPs\n    });\n\n    if (results && results[0]?.result) {\n      const detectedIPs = results[0].result;\n      \n      if (detectedIPs.length > 0) {\n        // Store detected IPs\n        await chrome.storage.local.set({\n          detectedIPs: detectedIPs,\n          fromPageDetection: true,\n          sourceUrl: tab.url,\n          sourceTitle: tab.title,\n          timestamp: Date.now()\n        });\n\n        await showBackgroundNotification(\n          'IPs Detected', \n          `Found ${detectedIPs.length} IP address${detectedIPs.length > 1 ? 'es' : ''} on this page`\n        );\n\n        await chrome.action.openPopup();\n      } else {\n        await showBackgroundNotification('No IPs Found', 'No IP addresses detected on this page');\n      }\n    }\n  } catch (error) {\n    console.error('Page IP detection failed:', error);\n    await showBackgroundNotification('Detection Failed', 'Could not scan page for IP addresses');\n  }\n}\n\n// Handle opening extension\nasync function handleOpenExtension(): Promise<void> {\n  await chrome.action.openPopup();\n}\n\n// Detect IP in selected text\nfunction detectIPInText(text: string): { ip: string; type: string } | null {\n  // Try different IP patterns\n  for (const [type, pattern] of Object.entries(BACKGROUND_IP_PATTERNS)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 0) {\n      return {\n        ip: matches[0],\n        type: type\n      };\n    }\n  }\n\n  return null;\n}\n\n// Function to be injected into page for IP detection (renamed to avoid conflict)\nfunction injectableDetectAllIPs(): Array<{\n  ip: string;\n  type: string;\n  context: string;\n  element: string;\n}> {\n  const detectedIPs: Array<{\n    ip: string;\n    type: string;\n    context: string;\n    element: string;\n  }> = [];\n\n  // IP patterns\n  const patterns = {\n    ethereum: /0x[a-fA-F0-9]{40}/g,\n    ensName: /[a-zA-Z0-9-]+\\.eth/g\n  };\n\n  // Get all text content\n  const walker = document.createTreeWalker(\n    document.body,\n    NodeFilter.SHOW_TEXT,\n    null\n  );\n\n  const textNodes: Text[] = [];\n  let node;\n  while (node = walker.nextNode()) {\n    textNodes.push(node as Text);\n  }\n\n  // Search for IPs in text nodes\n  textNodes.forEach(textNode => {\n    const text = textNode.textContent || '';\n    \n    for (const [type, pattern] of Object.entries(patterns)) {\n      const matches = text.match(pattern);\n      if (matches) {\n        matches.forEach(match => {\n          // Get context around the IP\n          const index = text.indexOf(match);\n          const start = Math.max(0, index - 50);\n          const end = Math.min(text.length, index + match.length + 50);\n          const context = text.slice(start, end);\n\n          // Get element info\n          const element = textNode.parentElement;\n          const elementInfo = element ? \n            `${element.tagName.toLowerCase()}${element.className ? '.' + element.className : ''}` : \n            'text';\n\n          detectedIPs.push({\n            ip: match,\n            type: type,\n            context: context.trim(),\n            element: elementInfo\n          });\n        });\n      }\n    }\n  });\n\n  // Remove duplicates\n  const uniqueIPs = detectedIPs.filter((ip, index, self) => \n    index === self.findIndex(t => t.ip === ip.ip)\n  );\n\n  return uniqueIPs;\n}\n\n// Get IP type from menu ID\nfunction getIPTypeFromMenuId(menuId: string): string {\n  const typeMap: Record<string, string> = {\n    'analyzeAsOriginal': 'original',\n    'analyzeAsDerivative': 'derivative',\n    'analyzeAsLicense': 'license',\n    'analyzeIP': 'unknown'\n  };\n  \n  return typeMap[menuId] || 'unknown';\n}\n\n// Show notification (renamed to avoid conflict)\nasync function showBackgroundNotification(title: string, message: string): Promise<void> {\n  try {\n    await chrome.notifications.create({\n      type: 'basic',\n      iconUrl: 'assets/icons/icon48.png',\n      title: title,\n      message: message\n    });\n  } catch (error) {\n    console.error('Notification failed:', error);\n  }\n}\n\n// Handle messages from content script and popup\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log('Background received message:', request);\n\n  switch (request.action) {\n    case 'analyzeIP':\n      handleAnalyzeIPMessage(request, sender, sendResponse);\n      break;\n      \n    case 'getStoredIP':\n      handleGetStoredIPMessage(request, sender, sendResponse);\n      break;\n      \n    case 'getDetectedIPs':\n      handleGetDetectedIPsMessage(request, sender, sendResponse);\n      break;\n      \n    case 'clearStoredData':\n      handleClearStoredDataMessage(request, sender, sendResponse);\n      break;\n  }\n\n  return true; // Keep message channel open for async response\n});\n\n// Handle analyze IP message\nasync function handleAnalyzeIPMessage(\n  request: any, \n  sender: chrome.runtime.MessageSender, \n  sendResponse: (response: any) => void\n): Promise<void> {\n  try {\n    await chrome.storage.local.set({\n      selectedIP: request.ipId,\n      fromMessage: true,\n      timestamp: Date.now()\n    });\n    sendResponse({ success: true });\n  } catch (error) {\n    sendResponse({ success: false, error: (error as Error).message });\n  }\n}\n\n// Handle get stored IP message\nasync function handleGetStoredIPMessage(\n  request: any, \n  sender: chrome.runtime.MessageSender, \n  sendResponse: (response: any) => void\n): Promise<void> {\n  try {\n    const result = await chrome.storage.local.get([\n      'selectedIP', \n      'ipType',\n      'fromContextMenu', \n      'fromPageDetection',\n      'fromMessage',\n      'sourceUrl',\n      'sourceTitle',\n      'selectionContext',\n      'detectedIPs',\n      'searchType',\n      'timestamp'\n    ]);\n    \n    sendResponse(result);\n    \n    // Clear after retrieval\n    await chrome.storage.local.remove([\n      'fromContextMenu', \n      'fromPageDetection',\n      'fromMessage'\n    ]);\n  } catch (error) {\n    sendResponse({ error: (error as Error).message });\n  }\n}\n\n// Handle get detected IPs message\nasync function handleGetDetectedIPsMessage(\n  request: any, \n  sender: chrome.runtime.MessageSender, \n  sendResponse: (response: any) => void\n): Promise<void> {\n  try {\n    const result = await chrome.storage.local.get(['detectedIPs']);\n    sendResponse(result);\n  } catch (error) {\n    sendResponse({ error: (error as Error).message });\n  }\n}\n\n// Handle clear stored data message\nasync function handleClearStoredDataMessage(\n  request: any, \n  sender: chrome.runtime.MessageSender, \n  sendResponse: (response: any) => void\n): Promise<void> {\n  try {\n    await chrome.storage.local.clear();\n    sendResponse({ success: true });\n  } catch (error) {\n    sendResponse({ success: false, error: (error as Error).message });\n  }\n}\n\n// Handle extension icon click\nchrome.action.onClicked.addListener((tab) => {\n  chrome.action.openPopup();\n});\n\n// Listen for tab updates to detect IPs automatically\nchrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\n  if (changeInfo.status === 'complete' && tab.url) {\n    // Auto-detect IPs on page load (optional)\n    try {\n      const results = await chrome.scripting.executeScript({\n        target: { tabId: tabId },\n        func: injectableDetectAllIPs\n      });\n\n      if (results && results[0]?.result) {\n        const ips = results[0].result;\n        if (ips.length > 0) {\n          backgroundDetectedIPs.set(tabId, ips.map(ip => ({\n            ...ip,\n            timestamp: Date.now()\n          })));\n          \n          // Update badge with IP count\n          await chrome.action.setBadgeText({\n            text: ips.length.toString(),\n            tabId: tabId\n          });\n          \n          await chrome.action.setBadgeBackgroundColor({\n            color: '#667eea',\n            tabId: tabId\n          });\n        }\n      }\n    } catch (error) {\n      // Silently fail for pages where we can't inject scripts\n    }\n  }\n});\n\n// Clear badge when tab is closed\nchrome.tabs.onRemoved.addListener((tabId) => {\n  backgroundDetectedIPs.delete(tabId);\n});"],"names":["console","log","BACKGROUND_IP_PATTERNS","ethereum","storyIP","ensName","contractAddress","backgroundDetectedIPs","Map","detectIPInText","text","type","pattern","Object","entries","matches","match","length","ip","injectableDetectAllIPs","detectedIPs","patterns","walker","document","createTreeWalker","body","NodeFilter","SHOW_TEXT","textNodes","node","nextNode","push","forEach","textNode","textContent","index","indexOf","start","Math","max","end","min","context","slice","element","parentElement","elementInfo","tagName","toLowerCase","className","trim","filter","self","findIndex","t","async","showBackgroundNotification","title","message","chrome","notifications","create","iconUrl","error","runtime","onInstalled","addListener","contextMenus","id","contexts","parentId","onClicked","info","tab","menuItemId","selectionText","selectedText","detectedIP","menuId","storage","local","set","selectedIP","ipType","fromContextMenu","sourceUrl","url","sourceTitle","timestamp","Date","now","selectionContext","action","openPopup","handleIPAnalysis","searchType","handleStoryIPSearch","results","scripting","executeScript","target","tabId","func","result","fromPageDetection","handlePageIPDetection","handleOpenExtension","onMessage","request","sender","sendResponse","ipId","fromMessage","success","handleAnalyzeIPMessage","get","remove","handleGetStoredIPMessage","handleGetDetectedIPsMessage","clear","handleClearStoredDataMessage","tabs","onUpdated","changeInfo","status","ips","map","setBadgeText","toString","setBadgeBackgroundColor","color","onRemoved","delete"],"sourceRoot":""}